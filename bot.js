require('dotenv').config();
const { Telegraf, Scenes, session, Markup } = require('telegraf');
const fs = require('fs');
const { initializeSheet, addOrder, cancelOrder, getActiveOrders } = require('./sheets');

// Check if bot token exists
if (!process.env.BOT_TOKEN) {
    console.error('BOT_TOKEN is not defined in .env file');
    process.exit(1);
}

// Check if spreadsheet ID exists
if (!process.env.SPREADSHEET_ID) {
    console.error('SPREADSHEET_ID is not defined in .env file');
    process.exit(1);
}

// Initialize bot with your token
const bot = new Telegraf(process.env.BOT_TOKEN);

// User data storage
let userData = {};

// Load user data from file if exists
try {
    userData = JSON.parse(fs.readFileSync('userData.json', 'utf8'));
} catch (error) {
    console.log('No existing user data found, starting fresh');
}

// Save user data to file
function saveUserData() {
    fs.writeFileSync('userData.json', JSON.stringify(userData, null, 2));
}

// Create keyboards
const mainKeyboard = Markup.keyboard([
    ['üìù –°–¥–µ–ª–∞—Ç—å –∑–∞–∫–∞–∑', 'üìç –ò–∑–º–µ–Ω–∏—Ç—å –∞–¥—Ä–µ—Å'],
    ['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–∫–∞–∑']
]).resize();

const orderKeyboard = Markup.keyboard([
    ['20 –∫–≥', '30 –∫–≥', '40 –∫–≥'],
    ['50 –∫–≥', '60 –∫–≥', '70 –∫–≥'],
    ['80 –∫–≥', '90 –∫–≥', '100 –∫–≥'],
    ['üîô –ù–∞–∑–∞–¥']
]).resize();

const dateKeyboard = Markup.keyboard([
    ['üìÖ –ù–∞ —Å–µ–≥–æ–¥–Ω—è', 'üìÖ –ù–∞ –∑–∞–≤—Ç—Ä–∞'],
    ['üìÖ –í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—É', 'üîô –ù–∞–∑–∞–¥']
]).resize();

// Scene for collecting venue name
const venueScene = new Scenes.BaseScene('venue');
venueScene.enter((ctx) => {
    ctx.reply(
        '–î–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –æ –∑–∞–≤–µ–¥–µ–Ω–∏–∏.\n\n' +
        '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–≤–µ–¥–µ–Ω–∏—è:',
        Markup.removeKeyboard()
    );
});

venueScene.on('text', async (ctx) => {
    const userId = ctx.from.id;
    userData[userId] = {
        ...userData[userId],
        venueName: ctx.message.text
    };
    saveUserData();
    await ctx.reply(
        `–ù–∞–∑–≤–∞–Ω–∏–µ –∑–∞–≤–µ–¥–µ–Ω–∏—è "${ctx.message.text}" —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ.\n\n` +
        '–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏:'
    );
    await ctx.scene.enter('address');
});

// Scene for collecting address
const addressScene = new Scenes.BaseScene('address');
addressScene.enter((ctx) => {
    ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏:');
});

addressScene.on('text', async (ctx) => {
    const userId = ctx.from.id;
    userData[userId] = {
        ...userData[userId],
        address: ctx.message.text
    };
    saveUserData();
    
    await ctx.reply(
        `–û—Ç–ª–∏—á–Ω–æ! –í—Å–µ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã:\n\n` +
        `–ó–∞–≤–µ–¥–µ–Ω–∏–µ: ${userData[userId].venueName}\n` +
        `–ê–¥—Ä–µ—Å: ${userData[userId].address}\n\n` +
        '–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å –∑–∞–∫–∞–∑:',
        mainKeyboard
    );
    await ctx.scene.leave();
});

// Scene for collecting order details
const orderScene = new Scenes.BaseScene('order');
orderScene.enter((ctx) => {
    ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª—å–¥–∞ (—à–∞–≥ 5 –∫–≥):', orderKeyboard);
});

orderScene.hears(/^\d+ –∫–≥$/, async (ctx) => {
    const amount = parseInt(ctx.message.text);
    const userId = ctx.from.id;
    
    if (!userData[userId]?.venueName || !userData[userId]?.address) {
        await ctx.reply('–°–Ω–∞—á–∞–ª–∞ –Ω—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–≤–µ–¥–µ–Ω–∏—è –∏ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏!');
        await ctx.scene.enter('venue');
        return;
    }

    // Store amount in session
    ctx.scene.state.amount = amount;
    await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É –¥–æ—Å—Ç–∞–≤–∫–∏:', dateKeyboard);
});

orderScene.hears('üìÖ –ù–∞ —Å–µ–≥–æ–¥–Ω—è', async (ctx) => {
    const userId = ctx.from.id;
    const amount = ctx.scene.state.amount;
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinutes = now.getMinutes();

    // Check if current time is before 17:00
    if (currentHour >= 17) {
        await ctx.reply(
            '–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –∑–∞–∫–∞–∑—ã –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–æ 17:00.\n' +
            '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –¥–∞—Ç—É –¥–æ—Å—Ç–∞–≤–∫–∏.',
            orderKeyboard
        );
        return;
    }

    const deliveryDate = now.toISOString().split('T')[0];

    const success = await addOrder(
        userId,
        userData[userId].venueName,
        userData[userId].address,
        amount,
        deliveryDate,
        now.toISOString()
    );

    if (success) {
        await ctx.reply(
            `–ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω!\n\n` +
            `–ó–∞–≤–µ–¥–µ–Ω–∏–µ: ${userData[userId].venueName}\n` +
            `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${amount} –∫–≥\n` +
            `–ê–¥—Ä–µ—Å: ${userData[userId].address}\n` +
            `–î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏: ${now.toLocaleDateString()}`,
            mainKeyboard
        );
    } else {
        await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∑–∞–∫–∞–∑–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
    
    await ctx.scene.leave();
});

orderScene.hears('üìÖ –ù–∞ –∑–∞–≤—Ç—Ä–∞', async (ctx) => {
    const userId = ctx.from.id;
    const amount = ctx.scene.state.amount;
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const deliveryDate = tomorrow.toISOString().split('T')[0];

    const success = await addOrder(
        userId,
        userData[userId].venueName,
        userData[userId].address,
        amount,
        deliveryDate,
        new Date().toISOString()
    );

    if (success) {
        await ctx.reply(
            `–ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω!\n\n` +
            `–ó–∞–≤–µ–¥–µ–Ω–∏–µ: ${userData[userId].venueName}\n` +
            `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${amount} –∫–≥\n` +
            `–ê–¥—Ä–µ—Å: ${userData[userId].address}\n` +
            `–î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏: ${tomorrow.toLocaleDateString()}`,
            mainKeyboard
        );
    } else {
        await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∑–∞–∫–∞–∑–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
    
    await ctx.scene.leave();
});

orderScene.hears('üìÖ –í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—É', async (ctx) => {
    await ctx.reply(
        '–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –¥–æ—Å—Ç–∞–≤–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì\n' +
        '–ù–∞–ø—Ä–∏–º–µ—Ä: 25.03.2024',
        Markup.removeKeyboard()
    );
});

orderScene.hears(/^(\d{2})\.(\d{2})\.(\d{4})$/, async (ctx) => {
    const userId = ctx.from.id;
    const amount = ctx.scene.state.amount;
    const [, day, month, year] = ctx.match;
    
    // Validate date
    const deliveryDate = new Date(year, month - 1, day);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    if (deliveryDate < today) {
        await ctx.reply('–ù–µ–ª—å–∑—è –≤—ã–±—Ä–∞—Ç—å –ø—Ä–æ—à–µ–¥—à—É—é –¥–∞—Ç—É. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –¥–∞—Ç—É.');
        return;
    }

    const success = await addOrder(
        userId,
        userData[userId].venueName,
        userData[userId].address,
        amount,
        deliveryDate.toISOString().split('T')[0],
        new Date().toISOString()
    );

    if (success) {
        await ctx.reply(
            `–ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω!\n\n` +
            `–ó–∞–≤–µ–¥–µ–Ω–∏–µ: ${userData[userId].venueName}\n` +
            `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${amount} –∫–≥\n` +
            `–ê–¥—Ä–µ—Å: ${userData[userId].address}\n` +
            `–î–∞—Ç–∞ –¥–æ—Å—Ç–∞–≤–∫–∏: ${deliveryDate.toLocaleDateString()}`,
            mainKeyboard
        );
    } else {
        await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∑–∞–∫–∞–∑–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
    
    await ctx.scene.leave();
});

orderScene.hears('üîô –ù–∞–∑–∞–¥', async (ctx) => {
    await ctx.reply('–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:', mainKeyboard);
    await ctx.scene.leave();
});

// Register scenes
const stage = new Scenes.Stage([venueScene, addressScene, orderScene]);
bot.use(session());
bot.use(stage.middleware());

// Start command
bot.command('start', async (ctx) => {
    const userId = ctx.from.id;
    if (userData[userId]?.venueName && userData[userId]?.address) {
        await ctx.reply(
            `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –∑–∞–∫–∞–∑–∞ –ª—å–¥–∞!\n\n` +
            `–¢–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ:\n` +
            `–ó–∞–≤–µ–¥–µ–Ω–∏–µ: ${userData[userId].venueName}\n` +
            `–ê–¥—Ä–µ—Å: ${userData[userId].address}\n\n` +
            `–ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å?`,
            mainKeyboard
        );
    } else {
        await ctx.reply('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –∑–∞–∫–∞–∑–∞ –ª—å–¥–∞! –î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –æ –∑–∞–≤–µ–¥–µ–Ω–∏–∏.');
        await ctx.scene.enter('venue');
    }
});

// Handle main menu actions
bot.hears('üìù –°–¥–µ–ª–∞—Ç—å –∑–∞–∫–∞–∑', async (ctx) => {
    await ctx.scene.enter('order');
});

bot.hears('üìç –ò–∑–º–µ–Ω–∏—Ç—å –∞–¥—Ä–µ—Å', async (ctx) => {
    await ctx.scene.enter('venue');
});

// Handle order cancellation
bot.hears('‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–∫–∞–∑', async (ctx) => {
    const userId = ctx.from.id;
    const activeOrders = await getActiveOrders(userId);

    if (activeOrders.length === 0) {
        await ctx.reply('–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤.');
        return;
    }

    const keyboard = Markup.keyboard(
        activeOrders.map(order => [`–û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–∫–∞–∑ ‚Ññ${order.index}: ${order.amount} –∫–≥`])
    ).resize();

    await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–∫–∞–∑ –¥–ª—è –æ—Ç–º–µ–Ω—ã:', keyboard);
});

// Handle order cancellation selection
bot.hears(/^–û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–∫–∞–∑ ‚Ññ(\d+): (\d+) –∫–≥$/, async (ctx) => {
    const userId = ctx.from.id;
    const orderIndex = parseInt(ctx.match[1]);
    
    const success = await cancelOrder(userId, orderIndex);
    
    if (success) {
        await ctx.reply('–ó–∞–∫–∞–∑ —É—Å–ø–µ—à–Ω–æ –æ—Ç–º–µ–Ω–µ–Ω.', mainKeyboard);
    } else {
        await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –∑–∞–∫–∞–∑–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.', mainKeyboard);
    }
});

// Order command
bot.command('order', async (ctx) => {
    await ctx.scene.enter('order');
});

// Address command
bot.command('address', async (ctx) => {
    await ctx.scene.enter('venue');
});

// Error handling
bot.catch((err, ctx) => {
    console.error(`Error for ${ctx.updateType}:`, err);
});

// Initialize Google Sheet and start the bot
async function startBot() {
    try {
        await initializeSheet();
        await bot.launch();
        console.log('Bot started');
    } catch (error) {
        console.error('Error starting bot:', error);
        process.exit(1);
    }
}

startBot();

// Enable graceful stop
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM')); 